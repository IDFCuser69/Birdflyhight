<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MAMA vs BANGLADESHI MIYA â€” Flappy Ball</title>
  <style>
    html,body{height:100%;margin:0;background:#e9f5ff;font-family:Arial,Helvetica,sans-serif}
    #game-wrap{display:flex;align-items:center;justify-content:center;height:100%}
    canvas{background:#78c0ff;border-radius:8px;box-shadow:0 8px 30px rgba(0,0,0,0.2)}
    .overlay{
      position:fixed;left:0;right:0;top:0;bottom:0;
      display:flex;align-items:center;justify-content:center;
      pointer-events:none;
    }
    .panel{
      pointer-events:auto;
      background:rgba(255,255,255,0.98);
      padding:18px 22px;border-radius:12px;
      box-shadow:0 6px 20px rgba(0,0,0,0.15);
      text-align:center;max-width:420px;width:90%;
    }
    .title{font-size:20px;font-weight:700;margin-bottom:6px}
    .big{font-size:36px;font-weight:800;margin:10px 0}
    .hint{color:#555;margin:8px 0}
    button{
      background:#017bff;color:white;border:0;padding:10px 16px;border-radius:8px;font-size:16px;cursor:pointer;
      box-shadow:0 6px 14px rgba(1,123,255,0.2);
    }
    .mutebtn{background:#f0f0f0;color:#111;margin-left:10px;padding:8px 10px}
    .scoreboard{position:absolute;left:18px;top:14px;color:#fff;font-weight:700;text-shadow:0 3px 8px rgba(0,0,0,0.35)}
    .high{position:absolute;right:18px;top:14px;color:#fff;font-weight:700;text-shadow:0 3px 8px rgba(0,0,0,0.35)}
    footer{position:fixed;left:0;right:0;bottom:14px;text-align:center;color:#333;font-size:12px}
  </style>
</head>
<body>
  <div id="game-wrap">
    <canvas id="c"></canvas>
    <div class="scoreboard" id="score">0</div>
    <div class="high" id="high">HIGH: 0</div>
  </div>

  <div class="overlay" id="overlay">
    <div class="panel" id="menu">
      <div class="title">MAMA vs BANGLADESHI MIYA</div>
      <div class="big">â–¶ PLAY</div>
      <div class="hint">Tap / Click to flap â€¢ Auto-shooting enabled â€¢ Avoid pipes!</div>
      <div style="margin-top:10px">
        <button id="startBtn">Start Game</button>
        <button id="muteBtn" class="mutebtn">ðŸ”Š Mute</button>
      </div>
    </div>

    <div class="panel" id="gameover" style="display:none">
      <div class="title">GAME OVER</div>
      <div class="big" id="finalScore">0</div>
      <div class="hint" id="scoreMsg">Try again and beat your high score!</div>
      <div style="margin-top:10px">
        <button id="retryBtn">Play Again</button>
      </div>
    </div>
  </div>

  <footer>Made ready for Netlify / GitHub Pages â€” Upload this file and host</footer>

<script>
/* ---------------------------
   ASSET LINKS (FROM YOU)
   --------------------------- */
const PIPES_IMG = "https://drive.google.com/uc?export=view&id=1ed0JreE46TfBk11XzwVqmODPPa0ivBuq";
const BALL_IMG  = "https://drive.google.com/uc?export=view&id=1T7e4VX9UITU11uRBV_jr_f9Jo2kG89Zv";
const DEATH_SOUND = "https://drive.google.com/uc?export=download&id=1ZwaubtQV-6yQmVa69CZQezUSaNbcSGDm";

/* ---------------------------
   CANVAS SETUP
   --------------------------- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = 480;
const H = 640;
canvas.width = W;
canvas.height = H;

let pipesImg = new Image();
let ballImg = new Image();
let deathAudio = new Audio(DEATH_SOUND);
deathAudio.preload = 'auto';

pipesImg.src = PIPES_IMG;
ballImg.src = BALL_IMG;

/* Some browsers require user interaction before playing audio.
   We'll only play the death sound after an interaction (start/retry). */

/* ---------------------------
   GAME STATE
   --------------------------- */
let gravity = 0.6;
let jump = -10.5;
let player = {};
let pipes = [];
let frame = 0;
let spawnInterval = 90; // frames
let pipeSpeed = 2.8;
let score = 0;
let best = Number(localStorage.getItem('mvbm_high')||0);
let running = false;
let muted = false;

/* UI elements */
const overlay = document.getElementById('overlay');
const menu = document.getElementById('menu');
const gameover = document.getElementById('gameover');
const startBtn = document.getElementById('startBtn');
const retryBtn = document.getElementById('retryBtn');
const muteBtn = document.getElementById('muteBtn');
const scoreEl = document.getElementById('score');
const highEl = document.getElementById('high');
const finalScore = document.getElementById('finalScore');
const scoreMsg = document.getElementById('scoreMsg');

highEl.textContent = "HIGH: " + best;

/* ---------------------------
   INITIALIZE / RESET
   --------------------------- */
function reset(){
  player = {
    x: 110,
    y: H/2,
    w: 46,
    h: 46,
    vy: 0,
    rot: 0
  };
  pipes = [];
  frame = 0;
  score = 0;
  spawnInterval = 90;
  pipeSpeed = 2.8;
  running = true;
  menu.style.display = 'none';
  gameover.style.display = 'none';
  updateScoreUI();
}

/* ---------------------------
   INPUT
   --------------------------- */
function flap(){
  if(!running) return;
  player.vy = jump;
  // small rotation animation
  player.rot = -0.6;
}
function tryStart(){
  if(!running){
    reset();
    // enable audio playback after user interaction
    if(!muted){
      deathAudio.pause();
      deathAudio.currentTime = 0;
    }
  }
}
canvas.addEventListener('mousedown', ()=>{ if(!running) tryStart(); flap(); });
canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); if(!running) tryStart(); flap(); }, {passive:false});
document.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ if(!running) tryStart(); flap(); } });

startBtn.addEventListener('click', ()=>{ tryStart(); });
retryBtn.addEventListener('click', ()=>{ tryStart(); });

muteBtn.addEventListener('click', ()=>{
  muted = !muted;
  muteBtn.textContent = muted ? "ðŸ”‡ Muted" : "ðŸ”Š Mute";
});

/* ---------------------------
   PIPES HELPER
   --------------------------- */
function spawnPipe(){
  const gap = 150; // gap size
  const minTop = 60;
  const maxTop = H - gap - 120;
  const top = Math.floor(Math.random() * (maxTop - minTop + 1)) + minTop;
  pipes.push({
    x: W + 20,
    top: top,
    bottomY: top + gap,
    passed: false
  });
}

/* ---------------------------
   COLLISION
   --------------------------- */
function rectsOverlap(ax,ay,aw,ah,bx,by,bw,bh){
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

/* ---------------------------
   UPDATE / DRAW
   --------------------------- */
function update(){
  if(!running) return;
  frame++;

  // spawn pipes periodically
  if(frame % spawnInterval === 0){
    spawnPipe();
    if(spawnInterval > 65) spawnInterval -= 1; // get harder slightly
    pipeSpeed += 0.02;
  }

  // player physics
  player.vy += gravity;
  player.y += player.vy;
  player.rot += 0.04;
  if(player.rot > 1.2) player.rot = 1.2;

  // floor/ceiling collision
  if(player.y + player.h > H - 6){
    player.y = H - 6 - player.h;
    gameOver();
  }
  if(player.y < 6){
    player.y = 6;
    player.vy = 0;
  }

  // pipes movement + scoring + collision
  for(let i=pipes.length-1;i>=0;i--){
    let p = pipes[i];
    p.x -= pipeSpeed;

    // scoring when passing
    if(!p.passed && p.x + 48 < player.x){
      p.passed = true;
      score++;
      updateScoreUI();
      // small speed up occasionally
      if(score % 7 === 0) pipeSpeed += 0.3;
    }

    // collision: top pipe rectangle and bottom pipe rectangle
    // We'll approximate pipe graphics with rectangles for collision detection
    const pipeW = 72;
    // top rect: x..x+pipeW, y: 0..p.top
    if(rectsOverlap(player.x, player.y, player.w, player.h, p.x, 0, pipeW, p.top)) {
      gameOver(); break;
    }
    // bottom rect: x..x+pipeW, y: p.bottomY..H
    if(rectsOverlap(player.x, player.y, player.w, player.h, p.x, p.bottomY, pipeW, H - p.bottomY)) {
      gameOver(); break;
    }

    // cleanup offscreen pipes
    if(p.x + 120 < 0) pipes.splice(i,1);
  }
}

/* ---------------------------
   GAMEOVER
   --------------------------- */
let ended = false;
function gameOver(){
  if(!running) return;
  running = false;
  ended = true;

  // play death sound (if not muted) - ensure user interaction activated audio first
  if(!muted){
    try{
      deathAudio.currentTime = 0;
      deathAudio.play().catch(()=>{/* play may require interaction; already handled on start */});
    }catch(e){}
  }

  // show overlay after tiny delay
  setTimeout(()=>{
    finalScore.textContent = score;
    scoreMsg.textContent = score > best ? "New High Score! Well done!" : "Try again and beat your high score!";
    if(score > best){ best = score; localStorage.setItem('mvbm_high', best); highEl.textContent = "HIGH: " + best; }
    gameover.style.display = 'block';
    menu.style.display = 'none';
  }, 160);
}

/* ---------------------------
   DRAW
   --------------------------- */
function draw(){
  // clear
  ctx.clearRect(0,0,W,H);

  // simple background gradient (sky)
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,"#78c0ff");
  g.addColorStop(1,"#7dd1ff");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // draw ground (simple)
  ctx.fillStyle = "#7fbf4f";
  ctx.fillRect(0,H-20,W,20);

  // draw pipes (top and bottom) using pipesImg if loaded, otherwise colored rect
  pipes.forEach(p=>{
    const px = Math.floor(p.x);
    const pipeW = 72;
    // top pipe: draw image flipped for top if available
    if(pipesImg.complete && pipesImg.naturalWidth){
      // draw top: scale image to fit width and height = p.top
      // We'll stretch the pipe image vertically to match p.top height
      ctx.save();
      // draw top (flipped vertically)
      ctx.translate(px + pipeW/2, p.top/2);
      ctx.scale(1, -1);
      ctx.drawImage(pipesImg, -pipeW/2, -p.top/2, pipeW, p.top);
      ctx.restore();

      // draw bottom
      ctx.drawImage(pipesImg, px, p.bottomY, pipeW, H - p.bottomY);
    } else {
      ctx.fillStyle = "#1e7b3a";
      ctx.fillRect(px, 0, pipeW, p.top);
      ctx.fillRect(px, p.bottomY, pipeW, H - p.bottomY);
    }
  });

  // draw player (ball)
  ctx.save();
  ctx.translate(player.x + player.w/2, player.y + player.h/2);
  ctx.rotate(player.rot);
  if(ballImg.complete && ballImg.naturalWidth){
    ctx.drawImage(ballImg, -player.w/2, -player.h/2, player.w, player.h);
  } else {
    ctx.fillStyle = "#ffdd57";
    ctx.beginPath();
    ctx.arc(0,0,player.w/2,0,Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}

/* ---------------------------
   MAIN LOOP
   --------------------------- */
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();

/* ---------------------------
   Score UI update
   --------------------------- */
function updateScoreUI(){
  scoreEl.textContent = score;
}

/* ---------------------------
   Start on first load: show menu
   --------------------------- */
running = false;
menu.style.display = 'block';
gameover.style.display = 'none';
overlay.style.pointerEvents = 'auto';

/* Ensure high shown */
highEl.textContent = "HIGH: " + best;

/* Try to preload images (no harm) */
pipesImg.onload = ()=>{/* ok */};
ballImg.onload = ()=>{/* ok */};

/* Small friendly hint in console */
console.log("Flappy Ball ready. Click Start Game then tap/click/space to flap.");

/* Prevent mobile double-tap zoom interfering */
document.addEventListener('touchmove', function(e){ if(running) e.preventDefault(); }, {passive:false});

</script>
</body>
</html>
